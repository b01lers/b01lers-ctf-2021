#define _GNU_SOURCE

#include <dlfcn.h>
#include <errno.h>
#include <stddef.h>
#include <link.h>
#include <pthread.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <wait.h>

#include <sys/mman.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/user.h>

#define PAGE_SIZE (sysconf(_SC_PAGESIZE))
#define PAGE_ROUND_DOWN(x) (((uint32_t)(x)) & (~(PAGE_SIZE-1)))
#define PAGE_ROUND_UP(x) ( (((uint32_t)(x)) + PAGE_SIZE-1)  & (~(PAGE_SIZE-1)) ) 

typedef struct targ {
    char buf[0x30];
    void * addr;
    int size;
    void * printf_positional_addr;
    pid_t pid;
} targ;

static void * pf_positional_offset = (void *) 0x3d6;
static void * pf_positional = (void *) 0xcafebabe;

int phdr_cb(struct dl_phdr_info * info, size_t size, void * data) {
    if (info->dlpi_name == NULL) {
        pf_positional = (void *) info->dlpi_addr;
    }
    return 0;
}

void * spray_graffiti(void * userdata) {
    struct targ * t = (struct targ *) userdata;

    /* Single step main process until it gets to the 
     * critical instruction */
    if (ptrace(PTRACE_ATTACH, t->pid, 0, 0) != 0) {
        fprintf(stdout, "ptrace: %s\n", strerror(errno));
    }

    int wait_stat = 0;
    int wait_res = waitpid(t->pid, &wait_stat, WUNTRACED);
    if (wait_res != t->pid || !WIFSTOPPED(wait_stat)) {
        fprintf(stdout, "waitpid: error.");
    }

    /* We have attach successfully....go go go! */
    while (1) {
        int sig_no = 0;
        const int p_res = ptrace(PTRACE_SINGLESTEP, t->pid, 0, sig_no);
        if (p_res < 0) {
            fprintf(stdout, "ptrace: %s\n", strerror(errno));
        }

        wait_res = wait(&wait_stat);
        sig_no = WSTOPSIG(wait_stat);
        if (sig_no = SIGTRAP) {
            sig_no = 0;
        } else {
            fprintf(stdout, "wait: unexpected signal");
        }

        /* SIngle stepped. Peek at eip address */
        struct user_regs_struct * regs = (struct user_regs_struct *) calloc(1, sizeof(struct user_regs_struct));
        ptrace(PTRACE_GETREGS, t->pid, NULL, (void *) regs);
        fprintf(stdout, "eip: %p printf_positional: %p\n", regs->eip, t->printf_positional_addr);
        
    }


    uint32_t ps = PAGE_SIZE;
    printf("Tagging. Start: %p End %p\n", t->addr, t->addr + (0x1000 * ps));
    while (1) {
        for (void * cur = t->addr; cur < t->addr + (0x999 * ps); cur += t->size) {
            memcpy(cur, t->buf, t->size);
        }
    }
    return NULL;
}

int main() {
    /* Set vbufs for IO */
    setvbuf(stdout, NULL, 0x2, 0x0);
    setvbuf(stdin, NULL, 0x2, 0x0);

    dl_iterate_phdr(phdr_cb, NULL);

    /* Probablistic, this covers the most common ESP
     * values after corruption */
    uint32_t addr = PAGE_ROUND_UP(0x7f900000);

    /* mmap 0x1000 pages of memor to probablistically
     * de-segfault the stack pivot in printf_positional */
    void * mapping = NULL;
    if ((mapping = mmap((void *) addr, 0x1000 * PAGE_SIZE, PROT_READ | PROT_WRITE, 
                    /* MAP_FIXED | */ MAP_ANONYMOUS | MAP_SHARED, -1, 0x0)) == (void *) -1) {
        fprintf(stdout, "mmap: %s\n", strerror(errno));
    } else {
        printf("mmap() -> (%p,%p)\n", mapping, mapping + (0x100 * PAGE_SIZE));
    }

    printf("Welcome to graffiti simulator! We have a pretty big\n"
        "wall here....tell me what I should cover it with.\n");

    /* Allow user to put in some ROP goodness */
    char chain_buf[0x30] = {0};
    printf("> ");
    fread(chain_buf, 0x1, 0x30, stdin);

    /* Unused currently. Allow user-specified offset
     * in case some crazy person wants to tune their
     * exploit */
    int offset;
    printf("> ");
    fscanf(stdin, "%d", &offset);
    getchar();

    /* This is the actual exploit. TODO: Filter for %n
     * because we don't want to allow blind printf overwrites */
    char buf[0x12] = {0};
    printf("> ");
    fgets(buf, 0x11, stdin);
    buf[0x11] = 0;

    for (char * bb = buf; bb < (buf + sizeof(buf)); bb++) {
        if (*bb == 'n') {
            _exit(1);
        }
    }

    /* Set up the thread argument */
    targ * t = (targ *)malloc(sizeof(targ));
    memcpy(t->buf, chain_buf, 0x30);
    t->addr = (void *) 0x7f900000;
    t->size = 0x30;
    t->printf_positional_addr = pf_positional;
    t->pid = gettid();

    /* Start a thread of spray_graffiti that overwrites the
     * mapped region with the user-controlled data repeatedly */

    /* TODO: Lower probability but increase frequency ? */
    pthread_t tid;
    pthread_create(&tid, NULL, spray_graffiti, t);

    /* Wait for the overwrite to happen */

    /* Echo as a sservice ha ha ha */
    printf("%s\n", buf);

    /* Inputs to solve */
    // AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
    // 0
    // %2$.2147483616$p

    /* Trigger printf vulnerability */
    FILE * dn = fopen("/dev/null", "w");
    /* TODO: Determine if this triggers it... */
    fprintf(dn, buf);
    fclose(dn);

    pthread_kill(tid, SIGSTOP);
    _exit(0);
}

