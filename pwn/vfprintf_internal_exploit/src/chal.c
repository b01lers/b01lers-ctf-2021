#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <stdint.h>
#include <pthread.h>

#define PAGE_SIZE (sysconf(_SC_PAGESIZE))
#define PAGE_ROUND_DOWN(x) (((uint32_t)(x)) & (~(PAGE_SIZE-1)))
#define PAGE_ROUND_UP(x) ( (((uint32_t)(x)) + PAGE_SIZE-1)  & (~(PAGE_SIZE-1)) ) 

typedef struct targ {
    char buf[0x30];
    void * addr;
    int size;
} targ;

void * spray_graffiti(void * userdata) {
    struct targ * t = (struct targ *) userdata;
    uint32_t ps = PAGE_SIZE;
    printf("Tagging. Start: %p End %p\n", t->addr, t->addr + (0x1000 * ps));
    while (1) {
        for (void * cur = t->addr; cur < t->addr + (0x999 * ps); cur += t->size) {
            memcpy(cur, t->buf, t->size);
        }
    }
    return NULL;
}

int main() {
    /* Set vbufs for IO */
    setvbuf(stdout, NULL, 0x2, 0x0);
    setvbuf(stdin, NULL, 0x2, 0x0);

    /* Probablistic, this covers the most common ESP
     * values after corruption */
    uint32_t addr = PAGE_ROUND_UP(0x7f900000);

    /* mmap 0x1000 pages of memor to probablistically
     * de-segfault the stack pivot in printf_positional */
    void * mapping = NULL;
    if ((mapping = mmap((void *) addr, 0x1000 * PAGE_SIZE, PROT_READ | PROT_WRITE, 
                    /* MAP_FIXED | */ MAP_ANONYMOUS | MAP_SHARED, -1, 0x0)) == (void *) -1) {
        fprintf(stdout, "mmap: %s\n", strerror(errno));
    } else {
        printf("mmap() -> (%p,%p)\n", mapping, mapping + (0x100 * PAGE_SIZE));
    }

    printf("Welcome to graffiti simulator! We have a pretty big\n"
        "wall here....tell me what I should cover it with.\n");

    /* Allow user to put in some ROP goodness */
    char chain_buf[0x30] = {0};
    printf("> ");
    fread(chain_buf, 0x1, 0x30, stdin);

    /* Unused currently. Allow user-specified offset
     * in case some crazy person wants to tune their
     * exploit */
    int offset;
    printf("> ");
    fscanf(stdin, "%d", &offset);
    getchar();

    /* This is the actual exploit. TODO: Filter for %n
     * because we don't want to allow blind printf overwrites */
    char buf[0x12] = {0};
    printf("> ");
    fgets(buf, 0x11, stdin);
    buf[0x11] = 0;

    for (char * bb = buf; bb < (buf + sizeof(buf)); bb++) {
        if (*bb == 'n') {
            _exit(1);
        }
    }

    /* Set up the thread argument */
    targ * t = (targ *)malloc(sizeof(targ));
    memcpy(t->buf, chain_buf, 0x30);
    t->addr = (void *) 0x7f900000;
    t->size = 0x30;

    /* Start a thread of spray_graffiti that overwrites the
     * mapped region with the user-controlled data repeatedly */

    /* TODO: Lower probability but increase frequency ? */
    pthread_t tid;
    pthread_create(&tid, NULL, spray_graffiti, t);

    /* Wait for the overwrite to happen */
    int i = 1;
    while (1) {
        if (i++ == 1000000000) {
            break;
        }
    }

    /* Echo as a sservice ha ha ha */
    printf("%s\n", buf);

    /* Inputs to solve */
    // AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
    // 0
    // %2$.2147483616$p

    /* Trigger printf vulnerability */
    printf(buf);

    pthread_kill(tid, SIGSTOP);
    _exit(0);
}

